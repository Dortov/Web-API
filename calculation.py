import sys

class Calc:

    # Функция удаления дублей или совмещения пересекающихся периодов по максимальному периоду
    def clear(self, dict_):

        if len(dict_) <= 1:  # если словаре только один список (период), возвращаем его без сравнения
            return dict_

        else:
            renewed = {}  # создаем новый словарь
            d = []
            for list_ in dict_:  # прописываем в списках полученного словаря все промежуточные значения отрезков
                s = [i for i in range(dict_[list_][0], dict_[list_][1] + 1)]
                d += s  # и закидываем в один список d

            t = list(set(d))  # очищаем полученный список от дублей и сортируем по порядку
            t.sort()

            # дальше снова разбиваем список на отрезки
            s = []  # создаем пустой список для элементов нашего списка, перед которым шел пропуск
            for i in range(1, len(t)):  # заполняем список разрывов во временном ряде
                if t[i] != t[i - 1] + 1:
                    s.append(i)

            n = 1  # определяем переменную для нумерации будущего словаря
            for i in s:  # разрезаем наш список t по разрывам и отрезки закидываем в словарь renewed
                c = t[:s[0]]
                renewed.setdefault(n, c)
                n += 1
                del t[:s[0]]
            renewed.setdefault(n, t)  # в конце помещаем в словарь оставшийся отрезок списка t

            for i in renewed:  # убираем в списках словаря renewed все значения, кроме первого и последнего, оставляя отрезки
                renewed[i] = [renewed[i][0], renewed[i][-1]]

            return renewed

    # Функция соединения двух словарей с временными периодами по совпадениям
    def compare(self, d1, d2):

        # при выявлении совпадения между двумя непрерывными временными периодами у нас может быть 6 вариантов:
        # 2.1 точки начала и окончания первого периода находятся внутри точек второго периода (первый период полностью входит во второй)
        # 2.2 обе точки второго периода находятся внутри точек первого (второй период полностью входит в первый)
        # 2.3 точка начала первого периода находится внутри второго периода, точка окончания первого > точки окончания второго (первый период начался во время второго и закончился после окончания второго)
        # 2.4 точка окончания первого периода находится внутри второго периода, точка начала первого < точки начала второго (первый период начался раньше второго, закончился во время второго)
        # 2.5 и 2.6 точки начала и окончания первого периода > точки окончания второго периода или < точки начала второго периода (периоды не имеют совпадений)
        # что и отобразим в коде:

        n = 1  # переменная для нумерации ключей в новом словаре
        final_dict = {}  # итоговый словарь
        for j in d1:
            for i in d2:
                # вариант 1
                if ((d2[i][0] <= d1[j][0] <= d2[i][1]) and (d2[i][0] <= d1[j][1] <= d2[i][1])):
                    final_dict.setdefault(n, [d1[j][0], d1[j][1]])
                    n += 1

                # вариант 2
                elif ((d1[j][0] <= d2[i][0] <= d1[j][1]) and (d1[j][0] <= d2[i][1] <= d1[j][1])):
                    final_dict.setdefault(n, [d2[i][0], d2[i][1]])
                    n += 1

                # вариант 3
                elif ((d2[i][0] <= d1[j][0] <= d2[i][1]) and (d2[i][1] < d1[j][1])):
                    final_dict.setdefault(n, [d1[j][0], d2[i][1]])
                    n += 1

                # вариант 4
                elif ((d1[j][0] < d2[i][0]) and (d2[i][0] <= d1[j][1] <= d2[i][1])):
                    final_dict.setdefault(n, [d2[i][0], d1[j][1]])
                    n += 1

                # 5 и 6 варианты можем не прописывать, так как они не добавляют никаких результатов в наши расчеты

        return final_dict

    def appearance(self, intervals):

        # 1. немного видоизменим словарь для удобства работы
        for i in intervals:
            d = {}
            s = 0
            n = 1
            period_list = []
            for stamp in intervals[i]:
                if s == 0:
                    period_list.append(stamp)
                    s += 1
                else:
                    period_list.append(stamp)
                    s -= 1
                    d.setdefault(n, period_list)
                    period_list = []
                    n += 1
            intervals[i] = d


        # 2. очищаем все значения словаря от дублей

        for i in intervals:
            intervals[i] = self.clear(intervals[i])

        # 3. производим поочередное сравнение словарей и соединяем в один

        compare1 = self.compare(intervals['lesson'], intervals['pupil'])
        final_dict = self.compare(compare1, intervals['tutor'])

        # 4. Считаем время общего совпадения

        s = 0  # вводим переменную общего времени
        for i in final_dict:
            s += (final_dict[i][1] - final_dict[i][0])

        return s